/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./example/index.ts":
/*!**************************!*\
  !*** ./example/index.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst Index_1 = __webpack_require__(/*! ../src/Index */ \"./src/Index.ts\");\nconst canvas = document.getElementById('myCanvas');\nconst cellSize = Math.pow(2, 6);\nconst system = new Index_1.System({\n    tickRate: 60,\n    friction: 0.1,\n    gravity: new Index_1.Vector(0, 0),\n    collisionInfo: {\n        cellSize: Math.log2(cellSize),\n    },\n    camera: {\n        zoom: 1,\n    },\n    dimensions: new Index_1.Vector(500, 500),\n    render: {\n        canvas,\n        background: '#FFFFFF',\n        gridColor: '#000000',\n        gridWidth: 1,\n    },\n});\nclass CircleBody extends Index_1.Body {\n    constructor() {\n        super(new Index_1.Circle({\n            form: { vertices: [new Index_1.Vector(80, 80)] },\n            radius: 10,\n            mass: 10,\n            speed: 1,\n            elasticity: 1,\n            angularSpeed: 1,\n            render: {\n                strokeColor: Index_1.Colors.Red,\n                strokeWidth: 1,\n            },\n        }));\n    }\n    getHit(other) {\n        console.log('hit!', other);\n    }\n}\nsystem.addBody(new CircleBody());\n\n\n//# sourceURL=webpack://kinetics.ts/./example/index.ts?");

/***/ }),

/***/ "./src/EventEmitter.ts":
/*!*****************************!*\
  !*** ./src/EventEmitter.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/** Polyfill for an event emitter. */\nclass EventEmitter {\n    constructor() {\n        this.events = {};\n    }\n    /** Adds a listener for an event. */\n    on(event, listener) {\n        if (!this.events[event])\n            this.events[event] = [];\n        this.events[event].push(listener);\n    }\n    /** Emits an event. */\n    emit(event, ...args) {\n        if (!this.events[event])\n            return;\n        for (const listener of this.events[event]) {\n            listener(...args);\n        }\n    }\n}\nexports[\"default\"] = EventEmitter;\n;\n\n\n//# sourceURL=webpack://kinetics.ts/./src/EventEmitter.ts?");

/***/ }),

/***/ "./src/Index.ts":
/*!**********************!*\
  !*** ./src/Index.ts ***!
  \**********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Colors = exports.ShapeType = exports.Environment = exports.Movement = exports.Vector = exports.Renderer = exports.Camera = exports.Collision = exports.Line = exports.Circle = exports.Polygon = exports.Shape = exports.Body = exports.System = void 0;\nconst System_1 = __importDefault(__webpack_require__(/*! ./System */ \"./src/System.ts\"));\nexports.System = System_1.default;\nconst CollisionResolver_1 = __importDefault(__webpack_require__(/*! ./collision/CollisionResolver */ \"./src/collision/CollisionResolver.ts\"));\nconst SpatialHashGrid_1 = __importDefault(__webpack_require__(/*! ./collision/SpatialHashGrid */ \"./src/collision/SpatialHashGrid.ts\"));\nconst Body_1 = __importDefault(__webpack_require__(/*! ./body/Body */ \"./src/body/Body.ts\"));\nexports.Body = Body_1.default;\nconst Shape_1 = __importDefault(__webpack_require__(/*! ./shapes/Shape */ \"./src/shapes/Shape.ts\"));\nexports.Shape = Shape_1.default;\nconst Polygon_1 = __importDefault(__webpack_require__(/*! ./shapes/Polygon */ \"./src/shapes/Polygon.ts\"));\nexports.Polygon = Polygon_1.default;\nconst Circle_1 = __importDefault(__webpack_require__(/*! ./shapes/Circle */ \"./src/shapes/Circle.ts\"));\nexports.Circle = Circle_1.default;\nconst Line_1 = __importDefault(__webpack_require__(/*! ./shapes/Line */ \"./src/shapes/Line.ts\"));\nexports.Line = Line_1.default;\nconst Camera_1 = __importDefault(__webpack_require__(/*! ./utils/Camera */ \"./src/utils/Camera.ts\"));\nexports.Camera = Camera_1.default;\nconst Renderer_1 = __importDefault(__webpack_require__(/*! ./utils/Renderer */ \"./src/utils/Renderer.ts\"));\nexports.Renderer = Renderer_1.default;\nconst Vector_1 = __importDefault(__webpack_require__(/*! ./utils/Vector */ \"./src/utils/Vector.ts\"));\nexports.Vector = Vector_1.default;\nconst Enums_1 = __webpack_require__(/*! ./typings/Enums */ \"./src/typings/Enums.ts\");\nObject.defineProperty(exports, \"Movement\", ({ enumerable: true, get: function () { return Enums_1.Movement; } }));\nObject.defineProperty(exports, \"Environment\", ({ enumerable: true, get: function () { return Enums_1.Environment; } }));\nObject.defineProperty(exports, \"ShapeType\", ({ enumerable: true, get: function () { return Enums_1.ShapeType; } }));\nObject.defineProperty(exports, \"Colors\", ({ enumerable: true, get: function () { return Enums_1.Colors; } }));\n// Check if the code is running in a web browser environment\nconst isWebEnvironment = typeof window !== 'undefined';\n// C O L L I S I O N\nexports.Collision = { CollisionResolver: CollisionResolver_1.default, SpatialHashGrid: SpatialHashGrid_1.default };\n// Attach the exports to the `window` object in a web environment\nif (isWebEnvironment) {\n    /** @ts-ignore */\n    window.Kinetics = {\n        System: System_1.default,\n        Body: Body_1.default,\n        Shape: Shape_1.default,\n        Polygon: Polygon_1.default,\n        Circle: Circle_1.default,\n        Collision: exports.Collision,\n        Camera: Camera_1.default,\n        Renderer: Renderer_1.default,\n        Vector: Vector_1.default,\n        Movement: Enums_1.Movement,\n        Environment: Enums_1.Environment,\n        ShapeType: Enums_1.ShapeType,\n        Colors: Enums_1.Colors,\n    };\n}\n\n\n//# sourceURL=webpack://kinetics.ts/./src/Index.ts?");

/***/ }),

/***/ "./src/System.ts":
/*!***********************!*\
  !*** ./src/System.ts ***!
  \***********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst Enums_1 = __webpack_require__(/*! ./typings/Enums */ \"./src/typings/Enums.ts\");\nconst Error_1 = __webpack_require__(/*! ./typings/Error */ \"./src/typings/Error.ts\");\nconst SpatialHashGrid_1 = __importDefault(__webpack_require__(/*! ./collision/SpatialHashGrid */ \"./src/collision/SpatialHashGrid.ts\"));\nconst CollisionResolver_1 = __importDefault(__webpack_require__(/*! ./collision/CollisionResolver */ \"./src/collision/CollisionResolver.ts\"));\nconst Camera_1 = __importDefault(__webpack_require__(/*! ./utils/Camera */ \"./src/utils/Camera.ts\"));\nconst Renderer_1 = __importDefault(__webpack_require__(/*! ./utils/Renderer */ \"./src/utils/Renderer.ts\"));\nconst EventEmitter_1 = __importDefault(__webpack_require__(/*! ./EventEmitter */ \"./src/EventEmitter.ts\"));\nconst Vector_1 = __importDefault(__webpack_require__(/*! ./utils/Vector */ \"./src/utils/Vector.ts\"));\n/** The area upon which the engine is operating on. */\nclass System extends EventEmitter_1.default {\n    /** Gets the momentum of the system. */\n    get momentum() {\n        let momentum = 0;\n        for (const body of this.bodys) {\n            if (!body)\n                continue;\n            momentum += body.velocity.magnitude * body.shape.mass + Math.abs(body.shape.angularVelocity * body.shape.inertia) * body.shape.mass;\n        }\n        return momentum;\n    }\n    /** Gets the kinetic energy of the system. */\n    get kineticEnergy() {\n        let energy = 0;\n        for (const body of this.bodys) {\n            if (!body)\n                continue;\n            energy += 0.5 * body.shape.mass * (body.velocity.magnitude * body.velocity.magnitude);\n        }\n        return energy;\n    }\n    /** Gets the next available ID. */\n    get nextId() {\n        const idx = this.bodys.indexOf(undefined);\n        if (idx !== -1)\n            return idx;\n        return this.bodys.length;\n    }\n    constructor(config) {\n        var _a, _b;\n        super();\n        /** The width of the system. */\n        this.width = null;\n        /** The height of the system. */\n        this.height = null;\n        /** The friction in the system. */\n        this.friction = 0.1;\n        /** The gravity in the system. */\n        this.gravity = new Vector_1.default(0, 0);\n        /** The engine which detects and resolves collisions. */\n        this.CollisionResolver = new CollisionResolver_1.default();\n        /** The bodys in the system. */\n        this.bodys = [];\n        /** Flag for logging messages to console. */\n        this.verbose = false;\n        /** The amount of ticks elapsed since the start of the engine. */\n        this.tick = 0;\n        /** The amount of tick cycles that occur in one second. */\n        this.tickRate = 0;\n        /** The environment the system is running in. */\n        this.environment = Enums_1.Environment.Browser;\n        /** The performance of the system. */\n        this.performance = {\n            /** The time it takes for a world update. */\n            worldUpdateRate: 0,\n            /** The amount of memory used, in bytes. */\n            memoryUsage: 0,\n        };\n        this.environment = typeof window === 'undefined' ? Enums_1.Environment.Node : Enums_1.Environment.Browser;\n        this.config = config;\n        this.width = ((_a = config.dimensions) === null || _a === void 0 ? void 0 : _a.x) || null;\n        this.height = ((_b = config.dimensions) === null || _b === void 0 ? void 0 : _b.y) || null;\n        if ((this.width && !this.height) || (this.height && !this.width))\n            throw new Error_1.ConfigurationError('Both dimensions must be specified for the system.');\n        this.friction = config.friction === undefined ? 0.1 : config.friction;\n        this.gravity = config.gravity === undefined ? new Vector_1.default(0, 0) : config.gravity;\n        this.camera = new Camera_1.default(config.camera || {}, this);\n        this.renderer = new Renderer_1.default(config.render, this);\n        this.verbose = config.verbose || false;\n        if (!config.collisionInfo)\n            throw new Error_1.ConfigurationError('Collision information must be specified for the system.');\n        this.CollisionManager = new SpatialHashGrid_1.default(this, config.collisionInfo.cellSize || 12);\n        if (this.verbose)\n            console.log('[PHYSICS]: Engine started.');\n        /** Handle ticksystem. */\n        if (this.environment === Enums_1.Environment.Browser && config.useRAF !== false) {\n            requestAnimationFrame(this.update.bind(this));\n            return;\n        }\n        this.tickRate = config.tickRate || 60;\n        setInterval(this.update.bind(this), 1000 / this.tickRate);\n        // if (config.useRAF) requestAnimationFrame(this.update.bind(this));\n        // else {\n        //     this.tickRate = config.tickRate || 60;\n        //     setInterval(this.update.bind(this), 1000 / this.tickRate);\n        // }\n    }\n    /** Sets the collision engine. */\n    setCollisionEngine(engine) {\n        this.CollisionManager = engine;\n    }\n    update() {\n        var _a;\n        const time = performance.now();\n        this.CollisionManager.clear();\n        for (const body of this.bodys) {\n            if (!body)\n                return;\n            this.CollisionManager.insert(body.shape.bounds.min.x, body.shape.bounds.min.y, body.shape.hitbox.x, body.shape.hitbox.y, body.id);\n            body.update();\n        }\n        this.CollisionManager.query();\n        this.tick++;\n        this.performance.worldUpdateRate = performance.now() - time;\n        /** @ts-ignore */\n        this.performance.memoryUsage = this.environment === Enums_1.Environment.Browser ? ((_a = performance.memory) === null || _a === void 0 ? void 0 : _a.usedJSHeapSize) / 1024 / 1024 : process.memoryUsage().heapUsed / 1024 / 1024;\n        if (this.environment === Enums_1.Environment.Browser && this.config.useRAF !== false)\n            requestAnimationFrame(this.update.bind(this));\n    }\n    /** Adds an body to the system. */\n    addBody(body) {\n        const id = this.nextId;\n        body.id = id;\n        this.bodys[id] = body;\n        this.emit('bodyCreate', body);\n        return body;\n    }\n    /** Removes an body from the system. */\n    removeBody(body) {\n        this.bodys[body.id] = undefined;\n        this.emit('bodyDelete', body);\n        return body;\n    }\n}\nexports[\"default\"] = System;\n\n\n//# sourceURL=webpack://kinetics.ts/./src/System.ts?");

/***/ }),

/***/ "./src/body/Body.ts":
/*!**************************!*\
  !*** ./src/body/Body.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/** The 'body' for all elements. */\nclass Body {\n    get velocity() {\n        return this.shape.velocity;\n    }\n    set velocity(velocity) {\n        this.shape.velocity = velocity;\n    }\n    constructor(shape) {\n        this.shape = shape;\n        this.shape.body = this;\n    }\n    getHit(other) { }\n    update() {\n        this.shape.update();\n    }\n    render(context) {\n        this.shape.render(context);\n    }\n}\nexports[\"default\"] = Body;\n\n\n//# sourceURL=webpack://kinetics.ts/./src/body/Body.ts?");

/***/ }),

/***/ "./src/collision/CollisionResolver.ts":
/*!********************************************!*\
  !*** ./src/collision/CollisionResolver.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst Enums_1 = __webpack_require__(/*! ../typings/Enums */ \"./src/typings/Enums.ts\");\n/** A class which performs narrowphase collision detection on entities. */\nclass CollisionResolver {\n    /** Detects collisions between two entities. */\n    detect(shape1, shape2) {\n        if (shape1.components.length && shape2.components.length) {\n            for (const component1 of shape1.components) {\n                for (const component2 of shape2.components) {\n                    const detected = this.detectSimple(component1, component2);\n                    if (detected)\n                        break;\n                }\n            }\n            return;\n        }\n        else if (shape1.components.length || shape2.components.length) {\n            const component = shape1.components.length ? shape1 : shape2;\n            const notComponent = shape1.components.length ? shape2 : shape1;\n            for (const subComponent of component.components) {\n                const detected = this.detectSimple(subComponent, notComponent);\n                if (detected)\n                    break;\n            }\n        }\n        else\n            this.detectSimple(shape1, shape2);\n    }\n    /** Detects collisions between two simple entities. */\n    detectSimple(shape1, shape2) {\n        if (shape1.type === Enums_1.ShapeType.Circle && shape2.type === Enums_1.ShapeType.Circle)\n            return this.detectCircleCircle(shape1, shape2);\n        if (shape1.type === Enums_1.ShapeType.Circle || shape2.type === Enums_1.ShapeType.Circle) {\n            const circle = shape1.type === Enums_1.ShapeType.Circle ? shape1 : shape2;\n            const notCircle = shape1.type === Enums_1.ShapeType.Circle ? shape2 : shape1;\n            return this.detectCirclePolygon(circle, notCircle);\n        }\n        let overlap = Infinity;\n        let smallestAxis;\n        const vertices1 = shape1.vertices;\n        const vertices2 = shape2.vertices;\n        const edges = vertices1.length + vertices2.length;\n        for (let i = 0; i < edges; i++) {\n            /** Calculate the orthogonal vector to each edge. */\n            let normal;\n            if (i < vertices1.length)\n                normal = vertices1[i].clone.subtract(vertices1[(i + 1) % vertices1.length]).orthogonal.normalize();\n            else\n                normal = vertices2[i - vertices1.length].clone.subtract(vertices2[(i + 1) % vertices2.length]).orthogonal.normalize();\n            /** Ignore zero vectors. */\n            if (normal.x === 0 && normal.y === 0)\n                continue;\n            /** Project each vertex onto the orthogonal vector. */\n            const [minA, maxA] = CollisionResolver.project(normal, vertices1);\n            const [minB, maxB] = CollisionResolver.project(normal, vertices2);\n            /** Calculate the overlap between the projections. */\n            const overlapN = Math.min(maxA, maxB) - Math.max(minA, minB);\n            if (overlapN <= 0)\n                return false;\n            /** Determine the smallest overlap. */\n            if (overlapN < overlap) {\n                smallestAxis = normal;\n                overlap = overlapN;\n            }\n        }\n        if (smallestAxis) {\n            this.resolve(shape1.parent || shape1, shape2.parent || shape2, Math.max(shape1.elasticity, shape2.elasticity), overlap, smallestAxis);\n            shape1.lastCollisionFrame = shape1.tick;\n            shape2.lastCollisionFrame = shape2.tick;\n            shape1.body.getHit(shape2.body);\n            shape2.body.getHit(shape1.body);\n            return true;\n        }\n        else\n            return false;\n    }\n    /** Detects collisions between a circle and a polygon. */\n    detectCirclePolygon(circle, polygon) {\n        const vertices = polygon.vertices;\n        let overlap = Infinity;\n        let smallestAxis;\n        for (let i = 0; i < vertices.length; i++) {\n            const vertex1 = vertices[i];\n            const vertex2 = vertices[(i + 1) % vertices.length];\n            const axis = vertex2.clone.subtract(vertex1).orthogonal.normalize();\n            if (axis.x === 0 && axis.y === 0)\n                continue;\n            const [min, max] = CollisionResolver.project(axis, vertices);\n            const circleProjection = circle.position.dot(axis);\n            const overlapN = Math.min(max, circleProjection + circle.radius) - Math.max(min, circleProjection - circle.radius);\n            if (overlapN <= 0)\n                return false;\n            if (overlapN < overlap) {\n                overlap = overlapN;\n                smallestAxis = axis;\n            }\n        }\n        if (smallestAxis) {\n            this.resolve(circle.parent || circle, polygon.parent || polygon, Math.max(circle.elasticity, polygon.elasticity), overlap, smallestAxis);\n            circle.lastCollisionFrame = circle.tick;\n            polygon.lastCollisionFrame = polygon.tick;\n            return true;\n        }\n        else\n            return false;\n    }\n    /** Detects collisions between two circles. */\n    detectCircleCircle(circle1, circle2) {\n        const distance = circle1.position.distance(circle2.position);\n        const overlap = circle1.radius + circle2.radius - distance;\n        const axis = circle1.position.clone.subtract(circle2.position).normalize();\n        if (overlap <= 0)\n            return false;\n        if (axis) {\n            this.resolve(circle1.parent || circle1, circle2.parent || circle2, Math.max(circle1.elasticity, circle2.elasticity), overlap, axis);\n            circle1.lastCollisionFrame = circle1.tick;\n            circle2.lastCollisionFrame = circle2.tick;\n            return true;\n        }\n        else\n            return false;\n    }\n    /** Projects the vertices onto the given axis. */\n    static project(axis, vertices) {\n        let min = Infinity;\n        let max = -Infinity;\n        for (const vertex of vertices) {\n            const projection = vertex.dot(axis);\n            min = Math.min(min, projection);\n            max = Math.max(max, projection);\n        }\n        return [min, max];\n    }\n    /** Resolves the collision between two entities. */\n    resolve(shape1, shape2, elasticity, overlap, axis) {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        (_b = (_a = shape1.hooks).preResolve) === null || _b === void 0 ? void 0 : _b.call(_a, shape2);\n        (_d = (_c = shape2.hooks).preResolve) === null || _d === void 0 ? void 0 : _d.call(_c, shape1);\n        if (shape1.position.dot(axis) < shape2.position.dot(axis))\n            axis.scale(-1);\n        const velocity1 = shape1.velocity;\n        const velocity2 = shape2.velocity;\n        const mass1 = shape1.mass;\n        const mass2 = shape2.mass;\n        const velocity = velocity1.clone.subtract(velocity2);\n        const velocityProjection = velocity.dot(axis);\n        const impulse = (-(1 + elasticity) * velocityProjection) / (1 / mass1 + 1 / mass2);\n        const impulseVector = axis.clone.scale(impulse);\n        /** Change the velocity by impulse and elasticity. */\n        if (!shape1.static)\n            shape1.velocity.add(impulseVector.clone.scale(1 / mass1));\n        if (!shape2.static)\n            shape2.velocity.subtract(impulseVector.clone.scale(1 / mass2));\n        /** Change the angular velocity of the entities. */\n        if (!shape1.static && !shape2.static) {\n            shape1.angularVelocity -= (1 / shape1.inertia) * shape1.position.clone.subtract(shape2.position).cross(impulseVector);\n            shape2.angularVelocity -= (1 / shape2.inertia) * shape1.position.clone.subtract(shape2.position).cross(impulseVector);\n        }\n        /** Move the entities out of each other. */\n        const penetration = axis.clone.scale(overlap / (1 / mass1 + 1 / mass2));\n        if (!shape1.static)\n            shape1.updatePosition(penetration.clone.scale(1 / mass1));\n        if (!shape2.static)\n            shape2.updatePosition(penetration.clone.scale(-1 / mass2));\n        (_f = (_e = shape1.hooks).postResolve) === null || _f === void 0 ? void 0 : _f.call(_e, shape2);\n        (_h = (_g = shape2.hooks).postResolve) === null || _h === void 0 ? void 0 : _h.call(_g, shape1);\n    }\n}\nexports[\"default\"] = CollisionResolver;\n\n\n//# sourceURL=webpack://kinetics.ts/./src/collision/CollisionResolver.ts?");

/***/ }),

/***/ "./src/collision/SpatialHashGrid.ts":
/*!******************************************!*\
  !*** ./src/collision/SpatialHashGrid.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst Error_1 = __webpack_require__(/*! ../typings/Error */ \"./src/typings/Error.ts\");\nconst hash = (x, y) => x + y * 0xb504;\n/** A binary space partitioning system which splits the arena into square cells.  */\nclass SpatialHashGrid {\n    constructor(system, cellSize) {\n        this.cells = new Map();\n        if (!Number.isInteger(cellSize) || cellSize >= 32)\n            throw new Error_1.ConfigurationError('Could not initialize SpatialHashGrid: Cell size must be an integer value less than 32.');\n        this.system = system;\n        this.cellSize = cellSize;\n    }\n    /** Inserts an body into the grid. */\n    insert(x, y, w, h, id) {\n        const startX = x >> this.cellSize;\n        const startY = y >> this.cellSize;\n        const endX = (x + w) >> this.cellSize;\n        const endY = (y + h) >> this.cellSize;\n        for (let x = startX; x <= endX; x++) {\n            for (let y = startY; y <= endY; y++) {\n                const key = hash(x, y);\n                if (!this.cells.get(key))\n                    this.cells.set(key, []);\n                this.cells.get(key).push(id);\n            }\n        }\n    }\n    /* Queries the grid by iterating over every cell and performing narrowphase detection on each body. */\n    query() {\n        for (const cell of this.cells.values()) {\n            const length = cell.length;\n            if (length < 2)\n                continue;\n            for (let i = 0; i < length; i++) {\n                for (let j = i + 1; j < length; j++) {\n                    const body1 = this.system.bodys[cell[i]];\n                    const body2 = this.system.bodys[cell[j]];\n                    if (body1.shape.sleeping && body2.shape.sleeping)\n                        continue;\n                    this.system.CollisionResolver.detect(body1.shape, body2.shape);\n                }\n            }\n        }\n    }\n    /** Clears the grid. */\n    clear() {\n        this.cells.clear();\n    }\n}\nexports[\"default\"] = SpatialHashGrid;\n\n\n//# sourceURL=webpack://kinetics.ts/./src/collision/SpatialHashGrid.ts?");

/***/ }),

/***/ "./src/shapes/Circle.ts":
/*!******************************!*\
  !*** ./src/shapes/Circle.ts ***!
  \******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst Shape_1 = __importDefault(__webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.ts\"));\nconst Enums_1 = __webpack_require__(/*! ../typings/Enums */ \"./src/typings/Enums.ts\");\nconst Error_1 = __webpack_require__(/*! ../typings/Error */ \"./src/typings/Error.ts\");\nconst Vector_1 = __importDefault(__webpack_require__(/*! ../utils/Vector */ \"./src/utils/Vector.ts\"));\n/** A specific geometric shape which represents a circle. */\nclass Circle extends Shape_1.default {\n    /** The bounds of the shape for the collision manager. */\n    get bounds() {\n        const vertex = this.position || this.vertices[0];\n        if (this.position === undefined)\n            this.position = vertex;\n        return {\n            min: new Vector_1.default(vertex.x - this.radius, vertex.y - this.radius),\n            max: vertex,\n            dimensions: this.hitbox,\n        };\n    }\n    /** The radius of the circle. */\n    get radius() {\n        return this._radius;\n    }\n    set radius(value) {\n        if (value <= 0)\n            throw new Error_1.ConfigurationError('The radius of a circle must be greater than 0.');\n        this._radius = value;\n    }\n    /** The hitbox of the circle. */\n    get hitbox() {\n        return new Vector_1.default(this.radius * 2, this.radius * 2);\n    }\n    /** The moment of inertia of the circle. */\n    get inertia() {\n        return this.static ? 0 : (this.mass * this.radius * this.radius) / 2;\n    }\n    constructor(info) {\n        super(info);\n        this.type = Enums_1.ShapeType.Circle;\n        this._radius = 0;\n        this.radius = info.radius;\n    }\n    /** Circles cannot rotate. Editing the angular velocity will deform the hitbox. */\n    rotate() { }\n    /** Renders the circle. */\n    render(context) {\n        const { stroke, fill } = this.determineColors();\n        if (this.rendering.glowIntensity) {\n            context.shadowBlur = this.rendering.glowIntensity;\n            context.shadowColor = (this.rendering.glowColor || stroke || fill);\n        }\n        context.beginPath();\n        if (fill)\n            context.fillStyle = fill;\n        if (stroke)\n            context.strokeStyle = stroke;\n        context.lineWidth = this.rendering.strokeWidth || 1;\n        context.arc(this.position.x, -this.position.y, this.radius, 0, 2 * Math.PI);\n        context.closePath();\n        context.stroke();\n        if (fill)\n            context.fill();\n        if (stroke)\n            context.stroke();\n    }\n}\nexports[\"default\"] = Circle;\n\n\n//# sourceURL=webpack://kinetics.ts/./src/shapes/Circle.ts?");

/***/ }),

/***/ "./src/shapes/Line.ts":
/*!****************************!*\
  !*** ./src/shapes/Line.ts ***!
  \****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst Enums_1 = __webpack_require__(/*! ../typings/Enums */ \"./src/typings/Enums.ts\");\nconst Vector_1 = __importDefault(__webpack_require__(/*! ../utils/Vector */ \"./src/utils/Vector.ts\"));\nconst Shape_1 = __importDefault(__webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.ts\"));\n/** A specific geometric shape which represents a straight line boundary. */\nclass Line extends Shape_1.default {\n    /** The vector which represents a vector from the start to the end. */\n    get line() {\n        return this.end.clone.subtract(this.start);\n    }\n    /** The vector which represents the direction of the start -> end vector. */\n    get lineDir() {\n        return this.line.normalize();\n    }\n    /** The length of the line. */\n    get length() {\n        return this.end.distance(this.start);\n    }\n    /** The corners of the collision detection range box. */\n    get minX() {\n        return Math.min(this.start.x, this.end.x);\n    }\n    get minY() {\n        return Math.min(this.start.y, this.end.y);\n    }\n    get maxX() {\n        return Math.max(this.start.x, this.end.x);\n    }\n    get maxY() {\n        return Math.max(this.start.y, this.end.y);\n    }\n    /** The width and height of the collision detection range boxes of the line. */\n    get width() {\n        return this.maxX - this.minX;\n    }\n    get height() {\n        return this.maxY - this.minY;\n    }\n    constructor(info) {\n        super(info);\n        this.type = Enums_1.ShapeType.Line;\n        this.start = new Vector_1.default(this.position.x, this.position.y);\n        this.end = new Vector_1.default(info.endX, info.endY);\n    }\n    /** Renders the line. */\n    render(context) {\n        const { stroke, fill } = this.determineColors();\n        if (this.rendering.glowIntensity) {\n            context.shadowBlur = this.rendering.glowIntensity;\n            context.shadowColor = (this.rendering.glowColor || stroke || fill);\n        }\n        context.beginPath();\n        if (fill)\n            context.fillStyle = fill;\n        if (stroke)\n            context.strokeStyle = stroke;\n        context.lineWidth = this.rendering.strokeWidth || 1;\n        context.moveTo(this.start.x, -this.start.y);\n        context.lineTo(this.end.x, -this.end.y);\n        context.closePath();\n        context.stroke();\n        if (fill)\n            context.fill();\n        if (stroke)\n            context.stroke();\n    }\n}\nexports[\"default\"] = Line;\n\n\n//# sourceURL=webpack://kinetics.ts/./src/shapes/Line.ts?");

/***/ }),

/***/ "./src/shapes/Polygon.ts":
/*!*******************************!*\
  !*** ./src/shapes/Polygon.ts ***!
  \*******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst Shape_1 = __importDefault(__webpack_require__(/*! ./Shape */ \"./src/shapes/Shape.ts\"));\nconst Enums_1 = __webpack_require__(/*! ../typings/Enums */ \"./src/typings/Enums.ts\");\nclass Polygon extends Shape_1.default {\n    constructor() {\n        super(...arguments);\n        this.type = Enums_1.ShapeType.Polygon;\n    }\n}\nexports[\"default\"] = Polygon;\n\n\n//# sourceURL=webpack://kinetics.ts/./src/shapes/Polygon.ts?");

/***/ }),

/***/ "./src/shapes/Shape.ts":
/*!*****************************!*\
  !*** ./src/shapes/Shape.ts ***!
  \*****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst Enums_1 = __webpack_require__(/*! ../typings/Enums */ \"./src/typings/Enums.ts\");\nconst Error_1 = __webpack_require__(/*! ../typings/Error */ \"./src/typings/Error.ts\");\nconst Vector_1 = __importDefault(__webpack_require__(/*! ../utils/Vector */ \"./src/utils/Vector.ts\"));\nconst Polygon_1 = __importDefault(__webpack_require__(/*! ./Polygon */ \"./src/shapes/Polygon.ts\"));\nconst Circle_1 = __importDefault(__webpack_require__(/*! ./Circle */ \"./src/shapes/Circle.ts\"));\nconst Line_1 = __importDefault(__webpack_require__(/*! ./Line */ \"./src/shapes/Line.ts\"));\n/** A representation of a geometric shape. */\nclass Shape {\n    /** Whether or not the shape is sleeping. */\n    get sleeping() {\n        return this.tick - this.lastCollisionFrame > 5 && Math.abs(this.velocity.x) < this.sleepThreshold && Math.abs(this.velocity.y) < this.sleepThreshold && Math.abs(this.angularVelocity) < this.sleepThreshold;\n    }\n    /** The hitbox of the shape. */\n    get hitbox() {\n        return this.bounds.max.subtract(this.bounds.min);\n    }\n    /** The moment of inertia of the shape. */\n    get inertia() {\n        if (this.static)\n            return 0;\n        const vertices = this.vertices;\n        let inertia = 0;\n        for (let i = 0; i < vertices.length; i++) {\n            const vertex1 = vertices[i];\n            const vertex2 = vertices[(i + 1) % vertices.length];\n            const term1 = vertex1.cross(vertex1) + vertex2.cross(vertex2);\n            const term2 = vertex1.cross(vertex2);\n            inertia += term1 + term2;\n        }\n        return Math.abs(inertia) / 12;\n    }\n    /** Gets the angle of the shape. */\n    get angle() {\n        return this._angle;\n    }\n    /** Sets the angle of the shape. */\n    set angle(value) {\n        if (value === this._angle || this.info.rotate === false)\n            return;\n        const angle = value - this._angle;\n        const cos = Math.cos(angle);\n        const sin = Math.sin(angle);\n        this._angle = value;\n        for (let i = 0; i < this.vertices.length; i++) {\n            const translatedX = this.vertices[i].x - this.position.x;\n            const translatedY = this.vertices[i].y - this.position.y;\n            const rotatedX = translatedX * cos - translatedY * sin;\n            const rotatedY = translatedX * sin + translatedY * cos;\n            this.vertices[i].x = rotatedX + this.position.x;\n            this.vertices[i].y = rotatedY + this.position.y;\n        }\n    }\n    /** The bounds of the shape for the collision manager. */\n    get bounds() {\n        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;\n        for (const vertex of this.vertices) {\n            const x = vertex.x;\n            const y = vertex.y;\n            minX = minX > x ? x : minX;\n            minY = minY > y ? y : minY;\n            maxX = maxX < x ? x : maxX;\n            maxY = maxY < y ? y : maxY;\n        }\n        if (this.position === undefined)\n            this.position = new Vector_1.default((minX + maxX) / 2, (minY + maxY) / 2);\n        return {\n            min: new Vector_1.default(minX, minY),\n            max: new Vector_1.default(maxX, maxY),\n        };\n    }\n    // TODO(Altanis): Angular and linear momentum.\n    /** The area of the shape. */\n    get area() {\n        let area = 0;\n        for (let i = 0; i < this.vertices.length; i++)\n            area += this.vertices[i].cross(this.vertices[(i + 1) % this.vertices.length]);\n        return Math.abs(area / 2);\n    }\n    constructor(info) {\n        /** The number of ticks elapsed since the shape's spawn. */\n        this.tick = 0;\n        /** The last tick the shape has collided with another. */\n        this.lastCollisionFrame = 0;\n        /** The threshold for the linear and angular velocities to put the shape to sleep. */\n        this.sleepThreshold = -1;\n        /** The geometric type of the shape. */\n        this.type = Enums_1.ShapeType.Generic;\n        /** The velocity of the shape. */\n        this.velocity = new Vector_1.default(0, 0);\n        /** The acceleration of the shape. */\n        this.acceleration = new Vector_1.default(0, 0);\n        /** The angular velocity of the shape. */\n        this.angularVelocity = 0;\n        /** The angular speed of the shape. */\n        this.angularSpeed = 0;\n        /** The components of the shape. */\n        this.components = [];\n        /** The parent of the shape (if it is a component.) */\n        this.parent = null;\n        /** The collision hooks of the shape. */\n        this.hooks = {};\n        this._angle = 0;\n        this.info = info;\n        this.vertices = this.initializeVertices(info);\n        this.bounds; // Initialize the bounds.\n        this.mass = info.mass;\n        this.angularSpeed = info.angularSpeed || 0;\n        this.elasticity = Math.max(0, info.elasticity) || 0;\n        this.static = !!info.static;\n        this.sleepThreshold = info.sleepThreshold === undefined ? -1 : info.sleepThreshold;\n        this.configure(info.render || {});\n        this.hooks = info.hooks || {};\n    }\n    /** Initializes the vertices of the shape. */\n    initializeVertices(info) {\n        if (!info.form)\n            throw new Error_1.ConfigurationError('No form was provided for the shape.');\n        let returnedVertices = [];\n        if (info.form.components) {\n            for (const component of info.form.components) {\n                if (component.form.components)\n                    throw new Error_1.ConfigurationError('Components cannot have components.');\n                /** @ts-ignore */\n                const shape = component.radius ? new Circle_1.default(component) : component.endX ? new Line_1.default(component) : new Polygon_1.default(component);\n                shape.parent = this;\n                shape.body = this.body;\n                this.components.push(shape);\n                returnedVertices.push(...shape.vertices);\n            }\n        }\n        else if (info.form.vertices)\n            returnedVertices = info.form.vertices;\n        else if (info.form.sides) {\n            const vertices = [];\n            const radius = info.form.radius;\n            if (!radius)\n                throw new Error_1.ConfigurationError('No radius was provided for the shape.');\n            const angleStep = (Math.PI * 2) / info.form.sides;\n            for (let i = 0; i < info.form.sides; i++) {\n                const startAngle = angleStep * i + (info.form.rotation || 0);\n                vertices.push(Vector_1.default.toCartesian(radius, startAngle).add(info.form.offset || { x: 0, y: 0 }));\n            }\n            returnedVertices = vertices;\n        }\n        else\n            throw new Error_1.ConfigurationError('No form was provided for the shape.');\n        return returnedVertices;\n    }\n    /** Configures the shape's rendering properties. */\n    configure(info) {\n        this.rendering = {\n            strokeColor: info.strokeColor,\n            fillColor: info.fillColor,\n            strokeWidth: info.strokeWidth || 1,\n            glowIntensity: info.glowIntensity,\n            glowColor: info.glowColor,\n            hooks: info.hooks || {},\n        };\n    }\n    /** Rotates the shape by its angular speed. */\n    rotate(...directions) {\n        for (const movement of directions) {\n            switch (movement) {\n                case Enums_1.Movement.Up:\n                    this.angularVelocity += this.angularSpeed;\n                    break;\n                case Enums_1.Movement.Down:\n                    this.angularVelocity -= this.angularSpeed;\n                    break;\n                case Enums_1.Movement.Left:\n                    this.angularVelocity -= this.angularSpeed;\n                    break;\n                case Enums_1.Movement.Right:\n                    this.angularVelocity += this.angularSpeed;\n                    break;\n                default:\n                    console.error('[SYSTEM]: Invalid angular movement key.');\n                    break;\n            }\n        }\n    }\n    /** Update the shape. */\n    update() {\n        if (this.static)\n            this.velocity.x = this.velocity.y = this.angularVelocity = 0;\n        /** Apply gravity. */\n        if (this.body.system.gravity && !this.static) {\n            this.velocity.add(this.body.system.gravity);\n        }\n        // if (this.sleeping) return;\n        this.velocity.scale(1 - this.body.system.friction); // Apply friction.\n        this.angularVelocity *= 1 - this.body.system.friction; // Apply friction.\n        this.updatePosition(this.velocity); // Apply velocity.\n        this.angle += this.angularVelocity / 100; // Apply angular velocity.\n        this.acceleration.scale(0); // Reset acceleration.\n        this.tick++;\n        this.body.system.emit('shapeUpdate', this);\n    }\n    /** Updates the position. */\n    updatePosition(vector) {\n        if (this.static)\n            return;\n        const width = this.body.system.width;\n        const height = this.body.system.height;\n        if (width && height) {\n            const halfWidth = width / 2;\n            const halfHeight = height / 2;\n            if (this.position.x + vector.x > halfWidth)\n                vector.x = halfWidth - this.position.x;\n            else if (this.position.x + vector.x < -halfWidth)\n                vector.x = -halfWidth - this.position.x;\n            if (this.position.y + vector.y > halfHeight)\n                vector.y = halfHeight - this.position.y;\n            else if (this.position.y + vector.y < -halfHeight)\n                vector.y = -halfHeight - this.position.y;\n        }\n        this.position.add(vector);\n        for (const vertex of this.vertices)\n            vertex.add(vector);\n    }\n    /** Determines the stroke and fill color of the shape. */\n    determineColors() {\n        let stroke = undefined;\n        let fill = undefined;\n        const shape = this;\n        if (shape.rendering.strokeColor)\n            stroke = shape.rendering.strokeColor;\n        if (shape.rendering.fillColor)\n            fill = shape.rendering.fillColor;\n        if (!stroke && !fill)\n            stroke = Enums_1.Colors.Black;\n        return { stroke, fill };\n    }\n    /** Renders the shape. */\n    render(context) {\n        const { stroke, fill } = this.determineColors();\n        if (this.rendering.glowIntensity) {\n            context.shadowBlur = this.rendering.glowIntensity;\n            context.shadowColor = (this.rendering.glowColor || stroke || fill);\n        }\n        context.beginPath();\n        if (stroke)\n            context.strokeStyle = stroke;\n        if (fill)\n            context.fillStyle = fill;\n        context.lineWidth = this.rendering.strokeWidth || 1;\n        if (this.components.length) {\n            for (const component of this.components) {\n                component.render(context);\n            }\n        }\n        else {\n            for (const vertex of this.vertices) {\n                context.lineTo(vertex.x, -vertex.y);\n            }\n        }\n        context.closePath();\n        if (fill)\n            context.fill();\n        if (stroke)\n            context.stroke();\n    }\n}\nexports[\"default\"] = Shape;\n\n\n//# sourceURL=webpack://kinetics.ts/./src/shapes/Shape.ts?");

/***/ }),

/***/ "./src/typings/Enums.ts":
/*!******************************!*\
  !*** ./src/typings/Enums.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Colors = exports.ShapeType = exports.Environment = exports.Movement = void 0;\n/** Enum representing movement. */\nvar Movement;\n(function (Movement) {\n    Movement[Movement[\"Up\"] = 0] = \"Up\";\n    Movement[Movement[\"Down\"] = 1] = \"Down\";\n    Movement[Movement[\"Left\"] = 2] = \"Left\";\n    Movement[Movement[\"Right\"] = 3] = \"Right\";\n})(Movement || (exports.Movement = Movement = {}));\n/** Enum representing the environment the program is running in. */\nvar Environment;\n(function (Environment) {\n    Environment[Environment[\"Browser\"] = 0] = \"Browser\";\n    Environment[Environment[\"Node\"] = 1] = \"Node\";\n    // Executable\n})(Environment || (exports.Environment = Environment = {}));\n/** Enum representing the geometric type of the entity. */\nvar ShapeType;\n(function (ShapeType) {\n    ShapeType[ShapeType[\"Generic\"] = 0] = \"Generic\";\n    ShapeType[ShapeType[\"Polygon\"] = 1] = \"Polygon\";\n    ShapeType[ShapeType[\"Circle\"] = 2] = \"Circle\";\n    ShapeType[ShapeType[\"Line\"] = 3] = \"Line\";\n})(ShapeType || (exports.ShapeType = ShapeType = {}));\n/** Enum representing different colors. */\nvar Colors;\n(function (Colors) {\n    Colors[\"Pink\"] = \"#F177DD\";\n    Colors[\"LightRed\"] = \"#FC7677\";\n    Colors[\"Red\"] = \"#F14E54\";\n    Colors[\"Yellow\"] = \"#FFE869\";\n    Colors[\"Peach\"] = \"#FCC376\";\n    Colors[\"Orange\"] = \"#FFA500\";\n    Colors[\"Green\"] = \"#00E16E\";\n    Colors[\"BrightGreen\"] = \"#43FF91\";\n    Colors[\"NeonGreen\"] = \"#8AFF69\";\n    Colors[\"Blue\"] = \"#00B2E1\";\n    Colors[\"DarkBlue\"] = \"#768DFC\";\n    Colors[\"Purple\"] = \"#BF7FF5\";\n    Colors[\"Gray\"] = \"#C0C0C0\";\n    Colors[\"Black\"] = \"#000000\";\n    Colors[\"White\"] = \"#FFFFFF\";\n})(Colors || (exports.Colors = Colors = {}));\n\n\n//# sourceURL=webpack://kinetics.ts/./src/typings/Enums.ts?");

/***/ }),

/***/ "./src/typings/Error.ts":
/*!******************************!*\
  !*** ./src/typings/Error.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ConfigurationError = exports.InternalError = void 0;\nclass InternalError extends Error {\n    constructor(message) {\n        super(\"[SYSTEM]: Whoops, something went wrong! Please report it at our GitHub page: \" + message);\n        this.name = \"InternalError\";\n    }\n}\nexports.InternalError = InternalError;\n;\nclass ConfigurationError extends Error {\n    constructor(message) {\n        super(\"[SYSTEM]: An error occurred when configuring an Entity or the System: \" + message);\n        this.name = \"ConfigurationError\";\n    }\n}\nexports.ConfigurationError = ConfigurationError;\n;\n\n\n//# sourceURL=webpack://kinetics.ts/./src/typings/Error.ts?");

/***/ }),

/***/ "./src/utils/Camera.ts":
/*!*****************************!*\
  !*** ./src/utils/Camera.ts ***!
  \*****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst Vector_1 = __importDefault(__webpack_require__(/*! ./Vector */ \"./src/utils/Vector.ts\"));\n/** A representation of the view of the system. */\nclass Camera {\n    /** Sets the camera's center position. */\n    setCenter(position) {\n        this.position.x = position.x;\n        this.position.y = position.y;\n    }\n    ;\n    /** Gets the system coordinates of a client MouseEvent. */\n    getSystemCoordinates(clientCoordinates) { }\n    ;\n    constructor({ position, zoom }, system) {\n        /** The position the camera is centered at. */\n        this.position = new Vector_1.default(0, 0);\n        /** The measure of how zoomed out the camera is. */\n        this.zoom = 1;\n        this.setCenter(position || new Vector_1.default(0, 0));\n        this.zoom = (zoom || 1);\n        this.system = system;\n    }\n    ;\n}\nexports[\"default\"] = Camera;\n;\n\n\n//# sourceURL=webpack://kinetics.ts/./src/utils/Camera.ts?");

/***/ }),

/***/ "./src/utils/Renderer.ts":
/*!*******************************!*\
  !*** ./src/utils/Renderer.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst Enums_1 = __webpack_require__(/*! ../typings/Enums */ \"./src/typings/Enums.ts\");\nconst Error_1 = __webpack_require__(/*! ../typings/Error */ \"./src/typings/Error.ts\");\n/** The class which handles rendering of the system. */\nclass Renderer {\n    constructor(config, system) {\n        /** Data about framerates. */\n        this.framerate = {\n            /** The list of the last 30 framerates. */\n            fpsArr: [],\n            /** The average framerate. */\n            fps: 0,\n            /** The delta between frames. */\n            dt: 0,\n            /** The last time the framerate was updated. */\n            lastUpdate: 0,\n        };\n        this.system = system;\n        if (!config || !config.canvas)\n            return;\n        this.canvas = config.canvas;\n        const ctx = this.canvas.getContext('2d');\n        if (!ctx)\n            throw new Error_1.ConfigurationError('Could not configure Renderer: Your browser does not support CanvasRenderingContext2D.');\n        this.context = ctx;\n        /** Ensure the canvas stays in bounds. */\n        window.addEventListener('resize', () => {\n            this.canvas.width = window.innerWidth * window.devicePixelRatio;\n            this.canvas.height = window.innerHeight * window.devicePixelRatio;\n        });\n        window.dispatchEvent(new Event('resize'));\n        this.configure(config);\n        requestAnimationFrame(this.render.bind(this));\n    }\n    /** Configures the renderer. */\n    configure(config) {\n        this.rendering = {\n            canvas: this.canvas,\n            background: config.background || Enums_1.Colors.White,\n            hooks: config.hooks || {},\n            gridSize: config.gridSize || 0,\n            gridColor: config.gridColor || Enums_1.Colors.Black,\n            gridWidth: config.gridWidth || 1,\n        };\n    }\n    /** Renders the system. */\n    render() {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        /** Update framerate information. */\n        this.framerate.dt = performance.now() - this.framerate.lastUpdate;\n        this.framerate.lastUpdate = performance.now();\n        if (this.framerate.fpsArr.length > 30)\n            this.framerate.fpsArr.shift();\n        this.framerate.fpsArr.push(this.framerate.dt);\n        let avg = 0;\n        for (const fps of this.framerate.fpsArr)\n            avg += fps;\n        this.framerate.fps = Math.round(1000 / (avg / this.framerate.fpsArr.length));\n        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);\n        this.context.save();\n        /** Render the background, boundaries, and grid. */\n        this.context.fillStyle = this.rendering.background;\n        this.context.fillRect(0, 0, this.canvas.width, this.canvas.height);\n        if (this.rendering.gridSize !== 0) {\n            this.context.strokeStyle = this.rendering.gridColor;\n            this.context.lineWidth = this.rendering.gridWidth;\n            for (let x = 0; x < this.canvas.width; x += this.rendering.gridSize) {\n                this.context.beginPath();\n                this.context.moveTo(x, 0);\n                this.context.lineTo(x, this.canvas.height);\n                this.context.stroke();\n            }\n            for (let y = 0; y < this.canvas.height; y += this.rendering.gridSize) {\n                this.context.beginPath();\n                this.context.moveTo(0, y);\n                this.context.lineTo(this.canvas.width, y);\n                this.context.stroke();\n            }\n        }\n        this.context.strokeStyle = this.rendering.gridColor;\n        /** Render the entities. */\n        this.context.translate(this.canvas.width / 2, this.canvas.height / 2);\n        this.context.scale(this.system.camera.zoom, this.system.camera.zoom);\n        (_b = (_a = this.rendering.hooks).preRender) === null || _b === void 0 ? void 0 : _b.call(_a, this.context);\n        for (const body of this.system.bodys) {\n            if (!body)\n                continue;\n            this.context.save();\n            (_d = (_c = body.shape.rendering.hooks).preRender) === null || _d === void 0 ? void 0 : _d.call(_c, body.shape, this.context);\n            body.render(this.context);\n            (_f = (_e = body.shape.rendering.hooks).postRender) === null || _f === void 0 ? void 0 : _f.call(_e, body.shape, this.context);\n            this.context.restore();\n        }\n        this.context.restore();\n        (_h = (_g = this.rendering.hooks).postRender) === null || _h === void 0 ? void 0 : _h.call(_g, this.context);\n        requestAnimationFrame(this.render.bind(this));\n    }\n}\nexports[\"default\"] = Renderer;\n\n\n//# sourceURL=webpack://kinetics.ts/./src/utils/Renderer.ts?");

/***/ }),

/***/ "./src/utils/Vector.ts":
/*!*****************************!*\
  !*** ./src/utils/Vector.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/** A vector in 2D space, represents a direction and magnitude simultaneously. */\nclass Vector {\n    constructor(x, y) {\n        /** The coordinates of the vector. */\n        this.x = 0;\n        this.y = 0;\n        this.x = x;\n        this.y = y;\n    }\n    /** Converts polar coordinates to Cartesian coordinates. */\n    static toCartesian(r, theta) {\n        return new Vector(r * Math.cos(theta), r * Math.sin(theta));\n    }\n    /** Adds to a vector. */\n    add(vector) {\n        this.x += vector.x;\n        this.y += vector.y;\n        return this;\n    }\n    /** Subtracts from a vector. */\n    subtract(vector) {\n        this.x -= vector.x;\n        this.y -= vector.y;\n        return this;\n    }\n    /** Scales from a vector. */\n    scale(scalar) {\n        this.x *= scalar;\n        this.y *= scalar;\n        return this;\n    }\n    /** Normalizes the vector. */\n    normalize() {\n        const magnitude = this.magnitude;\n        if (magnitude === 0)\n            this.x = this.y = 0;\n        else {\n            this.x /= magnitude;\n            this.y /= magnitude;\n        }\n        return this;\n    }\n    /** Gets the distance from another vector. */\n    distance(vector) {\n        return this.clone.subtract(vector).magnitude;\n    }\n    /** Gets the dot product of two vectors. */\n    dot(vector) {\n        return this.x * vector.x + this.y * vector.y;\n    }\n    /** Gets the cross product of two vectors. */\n    cross(vector) {\n        return this.x * vector.y - this.y * vector.x;\n    }\n    /** Gets the projection of the current vector onto another vector. */\n    project(vector) {\n        if (vector.x === 0 && vector.y === 0)\n            return new Vector(0, 0);\n        return vector.clone.scale(this.dot(vector) / vector.magnitudeSq);\n    }\n    ;\n    /** Creates a vector directionally orthogonal to the current vector. */\n    get orthogonal() {\n        return new Vector(-this.y, this.x);\n    }\n    /** Gets the angle of the vector from a reference point. */\n    angle(reference = { x: 0, y: 0 }) {\n        return Math.atan2(this.y - reference.y, this.x - reference.x);\n    }\n    /** Rotates the angle to a new angle. */\n    rotate(angle) {\n        const magnitude = this.magnitude;\n        this.x = magnitude * Math.cos(angle);\n        this.y = magnitude * Math.sin(angle);\n        return this;\n    }\n    /** Gets the magnitude (length) of the vector. */\n    get magnitude() {\n        return Math.sqrt(this.magnitudeSq);\n    }\n    ;\n    /** Sets the magnitude (length) of the vector. */\n    set magnitude(magnitude) {\n        const angle = this.angle();\n        this.x = magnitude * Math.cos(angle);\n        this.y = magnitude * Math.sin(angle);\n    }\n    ;\n    /** Gets the squared magnitude of the vector. */\n    get magnitudeSq() {\n        return this.x * this.x + this.y * this.y;\n    }\n    ;\n    /** Clones the vector. */\n    get clone() {\n        return new Vector(this.x, this.y);\n    }\n}\nexports[\"default\"] = Vector;\n;\n\n\n//# sourceURL=webpack://kinetics.ts/./src/utils/Vector.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./example/index.ts");
/******/ 	
/******/ })()
;